<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inknigma - Write in Invisible Ink</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        #control-panel {
            width: 320px;
            background: linear-gradient(135deg, #2e1a1a 0%, #3e1621 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #ff00d4;
            box-shadow: 4px 0 20px rgba(255, 0, 212, 0.3);
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        #canvas {
            display: block;
            cursor: inherit;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
            color: #ff00d4;
            text-shadow: 0 0 10px rgba(255, 0, 212, 0.5);
            text-align: center;
        }

        .tagline {
            font-size: 12px;
            color: #888;
            margin-bottom: 20px;
            font-style: italic;
            text-align: center;
        }

        .section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 0, 212, 0.2);
        }

        .section h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #ff00d4;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #ff00d4 0%, #cc0099 100%);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 11px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 0, 212, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.preview-mode {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
        }

        input[type="file"] {
            display: none;
        }

        .layer-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 0, 212, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 212, 0.3);
            transition: all 0.2s;
        }

        .layer-item.selected {
            background: rgba(255, 0, 212, 0.3);
            border-color: #ff00d4;
        }

        .layer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .layer-header input[type="radio"] {
            cursor: pointer;
        }

        .layer-header input[type="text"],
        .layer-header textarea {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 0, 212, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 5px;
            font-family: inherit;
            font-size: 12px;
        }

        .layer-header textarea {
            resize: vertical;
            min-height: 40px;
        }

        .layer-header .delete-btn {
            padding: 4px 8px;
            font-size: 10px;
            width: auto;
            margin: 0;
            background: rgba(255, 0, 0, 0.5);
        }

        .layer-header .delete-btn:hover {
            background: rgba(255, 0, 0, 0.7);
        }

        .layer-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            font-size: 11px;
        }

        .layer-controls label {
            color: #aaa;
        }

        .layer-controls input[type="number"] {
            width: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 0, 212, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 4px;
            font-size: 11px;
        }

        .effect-name {
            font-size: 11px;
            color: #ff88ff;
            font-weight: bold;
            text-align: center;
            padding: 4px;
            background: rgba(255, 0, 212, 0.1);
            border-radius: 4px;
        }

        .add-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid #ff00d4;
            font-size: 12px;
            color: #ff00d4;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .hint.visible {
            opacity: 1;
        }

        #layers-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .scroll-hint {
            font-size: 10px;
            color: #888;
            text-align: center;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 5px;
        }

        .param {
            margin: 8px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .param-label {
            color: #aaa;
        }

        .param-value {
            color: #ff88ff;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .lighting-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .lighting-controls input[type="number"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            color: #00d4ff;
            padding: 8px;
            font-size: 12px;
            text-align: center;
        }

        .lighting-name {
            font-size: 14px;
            color: #00ff88;
            font-weight: bold;
            text-align: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 4px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div id="control-panel">
        <h1>INKNIGMA</h1>
        <div class="tagline">Write in invisible ink</div>
        
        <div class="section">
            <button onclick="document.getElementById('base-image-input').click()">Load Base Image</button>
            <input type="file" id="base-image-input" accept="image/*">
        </div>

        <div class="section">
            <button id="preview-toggle-btn" onclick="app.togglePreviewMode()" disabled>
                Switch to Lighting Preview
            </button>
        </div>

        <div id="encoding-mode-panel">
            <div class="section">
                <h3>Hidden Layers</h3>
                <div id="layers-container"></div>
                <div class="add-buttons">
                    <button onclick="app.addTextLayer()">Add Text</button>
                    <button onclick="app.addImageLayer()">Add Image</button>
                </div>
                <div class="scroll-hint">Scroll over layer box to change effect<br>Shift+drag resize for fixed aspect<br>Ctrl+Scroll to zoom • Drag to pan</div>
            </div>

            <div class="section">
                <button onclick="app.resetView()">Reset View</button>
            </div>

            <div class="section">
                <button id="download-btn" onclick="app.downloadImage()" disabled>Download Image</button>
            </div>
        </div>

        <div id="lighting-mode-panel" style="display: none;">
            <div class="section">
                <h3>Lighting Preview</h3>
                <div class="lighting-name" id="lighting-name">No Effect</div>
                <div class="lighting-controls">
                    <input type="number" id="lighting-index-input" placeholder="Jump to effect #" min="1" max="177">
                    <div class="param">
                        <span class="param-label">Effect:</span>
                        <span class="param-value" id="lighting-index">0 / 177</span>
                    </div>
                    <div class="param">
                        <span class="param-label">Zoom:</span>
                        <span class="param-value" id="zoom-value-lighting">100%</span>
                    </div>
                </div>
                <div class="scroll-hint">
                    Scroll anywhere to change light<br>
                    Alt+Scroll for fast category jump<br>
                    Ctrl+Scroll to zoom • Drag to pan
                </div>
            </div>
            <div class="section">
                <button onclick="app.resetView()">Reset View</button>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="hint" id="hint">Load a base image to begin</div>
    </div>

    <input type="file" id="layer-image-input" accept="image/*" style="display: none;">

    <script>
        const app = {
            canvas: null,
            ctx: null,
            baseImage: null,
            layers: [],
            selectedLayerId: null,
            nextLayerId: 1,
            isDragging: false,
            isResizing: false,
            isRotating: false,
            dragStartX: 0,
            dragStartY: 0,
            dragOffsetX: 0,
            dragOffsetY: 0,
            
            // Zoom and pan
            scale: 1.0,
            panX: 0,
            panY: 0,
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            lastPanX: 0,
            lastPanY: 0,

            // Preview mode
            previewMode: 'encoding', // 'encoding' or 'lighting'
            currentLightingIndex: 0,
            
            // Cached rendered image
            cachedEncodedImage: null,

            // Steganography effects
            stegoEffects: [],
            
            // Lighting effects (Lucyra's detection methods)
            lightingEffects: [],
            effectGroups: [],

            // Calculate the transform from base image coordinates to canvas display coordinates
            getImageToCanvasTransform() {
                if (!this.baseImage) return { offsetX: 0, offsetY: 0, scale: 1 };

                const imgAspect = this.baseImage.width / this.baseImage.height;
                const canvasAspect = this.canvas.width / this.canvas.height;
                let displayScale, offsetX, offsetY;

                if (imgAspect > canvasAspect) {
                    // Image is wider - fit to width
                    displayScale = this.canvas.width / this.baseImage.width;
                    const displayHeight = this.baseImage.height * displayScale;
                    offsetX = 0;
                    offsetY = (this.canvas.height - displayHeight) / 2;
                } else {
                    // Image is taller - fit to height
                    displayScale = this.canvas.height / this.baseImage.height;
                    const displayWidth = this.baseImage.width * displayScale;
                    offsetX = (this.canvas.width - displayWidth) / 2;
                    offsetY = 0;
                }

                return { offsetX, offsetY, scale: displayScale };
            },

            // Convert canvas coordinates to image coordinates
            canvasToImage(canvasX, canvasY) {
                const transform = this.getImageToCanvasTransform();
                const x = (canvasX - transform.offsetX) / transform.scale;
                const y = (canvasY - transform.offsetY) / transform.scale;
                return { x, y };
            },

            // Convert image coordinates to canvas coordinates
            imageToCanvas(imageX, imageY) {
                const transform = this.getImageToCanvasTransform();
                const x = imageX * transform.scale + transform.offsetX;
                const y = imageY * transform.scale + transform.offsetY;
                return { x, y };
            },

            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.setupStegoEffects();
                this.setupLightingEffects();
                this.setupEventListeners();
                this.resizeCanvas();
            },

            setupStegoEffects() {
                const effects = [];

                // Match Lucyra's 177 effects in exact order
                // Brightness-based hiding (11 effects: 0-10)
                for (let i = 0; i <= 10; i++) {
                    const reduction = 1 / (0.5 + (i * 0.25));
                    effects.push({ 
                        name: `Dark Ink ${i}`, 
                        encode: this.encodeBrightness, 
                        params: { factor: reduction }
                    });
                }

                // Contrast-based hiding (21 effects: 11-31)
                for (let i = -8; i <= 12; i++) {
                    const inverse = -i * 0.5;
                    effects.push({ 
                        name: `Contrast ${i}`, 
                        encode: this.encodeContrast, 
                        params: { factor: inverse }
                    });
                }

                // RGB Channel hiding (15 effects: 32-46)
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let i = 1; i <= 5; i++) {
                        const reduction = 1 / (i * 0.5);
                        effects.push({ 
                            name: `${name} ${i}`, 
                            encode: this.encodeChannel, 
                            params: { channel: ch, factor: reduction }
                        });
                    }
                }

                // Pure channel encoding (3 effects: 47-49)
                effects.push({ name: 'Red Only', encode: this.encodePureChannel, params: { channel: 0 } });
                effects.push({ name: 'Green Only', encode: this.encodePureChannel, params: { channel: 1 } });
                effects.push({ name: 'Blue Only', encode: this.encodePureChannel, params: { channel: 2 } });

                // Inverted encoding (4 effects: 50-53)
                effects.push({ name: 'Invert All', encode: this.encodeInvert, params: {} });
                effects.push({ name: 'Invert R', encode: this.encodeInvertChannel, params: { channel: 0 } });
                effects.push({ name: 'Invert G', encode: this.encodeInvertChannel, params: { channel: 1 } });
                effects.push({ name: 'Invert B', encode: this.encodeInvertChannel, params: { channel: 2 } });

                // LSB steganography (24 effects: 54-77)
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let bit = 0; bit < 8; bit++) {
                        effects.push({ 
                            name: `${name} Bit ${bit}`, 
                            encode: this.encodeBitPlane, 
                            params: { channel: ch, bit }
                        });
                    }
                }

                // Color difference encoding (15 effects: 78-92)
                const pairs = [[0, 1, 'R-G'], [0, 2, 'R-B'], [1, 2, 'G-B']];
                for (const [ch1, ch2, label] of pairs) {
                    for (let i = 1; i <= 5; i++) {
                        effects.push({ 
                            name: `${label} ${i}`, 
                            encode: this.encodeColorDiff, 
                            params: { ch1, ch2, strength: 1 / i }
                        });
                    }
                }

                // Gradient-based hiding (3 effects: 93-95)
                effects.push({ name: 'H-Grad', encode: this.encodeGradient, params: { direction: 'horizontal' } });
                effects.push({ name: 'V-Grad', encode: this.encodeGradient, params: { direction: 'vertical' } });
                effects.push({ name: 'All Grad', encode: this.encodeGradient, params: { direction: 'both' } });

                // Statistical encoding (16 effects: 96-111)
                for (let i = 1; i <= 8; i++) {
                    const strength = 1 / (i * 2);
                    effects.push({ 
                        name: `Above Avg ${i}`, 
                        encode: this.encodeAboveAverage, 
                        params: { strength }
                    });
                }
                for (let i = 1; i <= 8; i++) {
                    const strength = 1 / (i * 2);
                    effects.push({ 
                        name: `Below Avg ${i}`, 
                        encode: this.encodeBelowAverage, 
                        params: { strength }
                    });
                }

                // HSL-based encoding (5 effects: 112-116)
                effects.push({ name: 'Hue Hide', encode: this.encodeHue, params: {} });
                effects.push({ name: 'Sat Hide', encode: this.encodeSaturation, params: {} });
                effects.push({ name: 'Lum Hide', encode: this.encodeLuminance, params: {} });
                effects.push({ name: 'Hue Amp', encode: this.encodeHueShift, params: {} });
                effects.push({ name: 'Sat Amp', encode: this.encodeSatShift, params: {} });

                // XOR encoding (10 effects: 117-126)
                for (const val of [1, 3, 7, 15, 31, 63, 85, 127, 170, 255]) {
                    effects.push({ 
                        name: `XOR ${val}`, 
                        encode: this.encodeXOR, 
                        params: { value: val }
                    });
                }

                // Edge-aware encoding (3 effects: 127-129)
                effects.push({ name: 'Edge Soft', encode: this.encodeEdge, params: { threshold: 0.5 } });
                effects.push({ name: 'Edge Norm', encode: this.encodeEdge, params: { threshold: 1.0 } });
                effects.push({ name: 'Edge Hard', encode: this.encodeEdge, params: { threshold: 1.5 } });

                // Posterization encoding (8 effects: 130-137)
                for (let levels = 2; levels <= 16; levels += 2) {
                    effects.push({ 
                        name: `Post ${levels}`, 
                        encode: this.encodePosterize, 
                        params: { levels }
                    });
                }

                // Modulo encoding (7 effects: 138-144)
                for (const mod of [2, 4, 8, 16, 32, 64, 128]) {
                    effects.push({ 
                        name: `Mod ${mod}`, 
                        encode: this.encodeModulo, 
                        params: { value: mod }
                    });
                }

                // Threshold encoding (7 effects: 145-151)
                for (let thresh = 32; thresh <= 224; thresh += 32) {
                    effects.push({ 
                        name: `Thresh ${thresh}`, 
                        encode: this.encodeThreshold, 
                        params: { value: thresh }
                    });
                }

                // Gamma encoding (9 effects: 152-160)
                for (let i = 1; i <= 9; i++) {
                    const gamma = 1 / (i * 0.3);
                    effects.push({ 
                        name: `Gamma ${i}`, 
                        encode: this.encodeGamma, 
                        params: { gamma }
                    });
                }

                // Color temperature encoding (11 effects: 161-171)
                for (let i = -5; i <= 5; i++) {
                    const temp = -i * 20;
                    effects.push({ 
                        name: `Temp ${i}`, 
                        encode: this.encodeColorTemp, 
                        params: { temp }
                    });
                }

                // Solarization encoding (5 effects: 172-176)
                for (let i = 1; i <= 5; i++) {
                    const level = i * 50;
                    effects.push({ 
                        name: `Solar ${level}`, 
                        encode: this.encodeSolarize, 
                        params: { level }
                    });
                }

                this.stegoEffects = effects;
            },

            setupLightingEffects() {
                const effects = [];

                // Exact copy of Lucyra's detection effects in same order
                
                // Brightness sweep (11 effects)
                for (let i = 0; i <= 10; i++) {
                    const boost = 0.5 + (i * 0.25);
                    effects.push({ name: `Brightness ${boost.toFixed(2)}x`, apply: this.brightness, params: { boost } });
                }

                // Contrast sweep (21 effects)
                for (let i = -8; i <= 12; i++) {
                    const factor = i * 0.5;
                    effects.push({ name: `Contrast ${factor.toFixed(1)}`, apply: this.contrast, params: { factor } });
                }

                // RGB Channel isolation with intensity variations (15 effects)
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let i = 1; i <= 5; i++) {
                        const factor = i * 0.5;
                        effects.push({ name: `${name} x${factor.toFixed(1)}`, apply: this.amplifyChannel, params: { channel: ch, factor } });
                    }
                }

                // Pure channel isolation (3 effects)
                effects.push({ name: 'Red Only', apply: this.isolateChannel, params: { channel: 0 } });
                effects.push({ name: 'Green Only', apply: this.isolateChannel, params: { channel: 1 } });
                effects.push({ name: 'Blue Only', apply: this.isolateChannel, params: { channel: 2 } });

                // Inverted variations (4 effects)
                effects.push({ name: 'Full Invert', apply: this.invert, params: {} });
                effects.push({ name: 'Invert Red', apply: this.invertChannel, params: { channel: 0 } });
                effects.push({ name: 'Invert Green', apply: this.invertChannel, params: { channel: 1 } });
                effects.push({ name: 'Invert Blue', apply: this.invertChannel, params: { channel: 2 } });

                // LSB visualization (24 effects)
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let bit = 0; bit < 8; bit++) {
                        effects.push({ name: `${name} Bit ${bit}`, apply: this.bitPlane, params: { channel: ch, bit } });
                    }
                }

                // Color differences with amplification (15 effects)
                const pairs = [[0, 1, 'R-G'], [0, 2, 'R-B'], [1, 2, 'G-B']];
                for (const [ch1, ch2, label] of pairs) {
                    for (let i = 1; i <= 5; i++) {
                        const amp = i;
                        effects.push({ name: `${label} Diff x${amp}`, apply: this.colorDifference, params: { ch1, ch2, amp } });
                    }
                }

                // Gradient detection (3 effects)
                effects.push({ name: 'H-Gradient', apply: this.gradientDetect, params: { direction: 'horizontal' } });
                effects.push({ name: 'V-Gradient', apply: this.gradientDetect, params: { direction: 'vertical' } });
                effects.push({ name: 'All Gradients', apply: this.gradientDetect, params: { direction: 'both' } });

                // Statistical thresholding (16 effects)
                for (let i = 1; i <= 8; i++) {
                    const boost = i * 2;
                    effects.push({ name: `Above Avg x${boost}`, apply: this.aboveAverage, params: { boost } });
                }
                for (let i = 1; i <= 8; i++) {
                    const boost = i * 2;
                    effects.push({ name: `Below Avg x${boost}`, apply: this.belowAverage, params: { boost } });
                }

                // HSL components (5 effects)
                effects.push({ name: 'Hue Only', apply: this.hueOnly, params: {} });
                effects.push({ name: 'Saturation Only', apply: this.saturationOnly, params: {} });
                effects.push({ name: 'Luminance Only', apply: this.luminanceOnly, params: {} });
                effects.push({ name: 'Hue Amplified', apply: this.hueAmplified, params: {} });
                effects.push({ name: 'Saturation Amplified', apply: this.saturationAmplified, params: {} });

                // XOR patterns (10 effects)
                for (const val of [1, 3, 7, 15, 31, 63, 85, 127, 170, 255]) {
                    effects.push({ name: `XOR ${val}`, apply: this.xorPattern, params: { value: val } });
                }

                // Edge detection variations (3 effects)
                effects.push({ name: 'Edges Soft', apply: this.edgeDetect, params: { threshold: 0.5 } });
                effects.push({ name: 'Edges Normal', apply: this.edgeDetect, params: { threshold: 1.0 } });
                effects.push({ name: 'Edges Hard', apply: this.edgeDetect, params: { threshold: 1.5 } });

                // Posterization (8 effects)
                for (let levels = 2; levels <= 16; levels += 2) {
                    effects.push({ name: `Posterize ${levels}`, apply: this.posterize, params: { levels } });
                }

                // Modulo operations (7 effects)
                for (const mod of [2, 4, 8, 16, 32, 64, 128]) {
                    effects.push({ name: `Modulo ${mod}`, apply: this.modulo, params: { value: mod } });
                }

                // Threshold operations (7 effects)
                for (let thresh = 32; thresh <= 224; thresh += 32) {
                    effects.push({ name: `Threshold ${thresh}`, apply: this.threshold, params: { value: thresh } });
                }

                // Gamma correction (9 effects)
                for (let i = 1; i <= 9; i++) {
                    const gamma = i * 0.3;
                    effects.push({ name: `Gamma ${gamma.toFixed(1)}`, apply: this.gamma, params: { gamma } });
                }

                // Color temperature shifts (11 effects)
                for (let i = -5; i <= 5; i++) {
                    const temp = i * 20;
                    effects.push({ name: `Temp ${temp > 0 ? '+' : ''}${temp}`, apply: this.colorTemp, params: { temp } });
                }

                // Solarization (5 effects)
                for (let i = 1; i <= 5; i++) {
                    const level = i * 50;
                    effects.push({ name: `Solarize ${level}`, apply: this.solarize, params: { level } });
                }

                this.lightingEffects = effects;
                
                // Build effect groups for Alt+scroll
                this.effectGroups = [0];
                let lastBaseName = '';
                for (let i = 0; i < effects.length; i++) {
                    const baseName = effects[i].name.replace(/[\d.+\-x]+/g, '').trim();
                    if (baseName !== lastBaseName && lastBaseName !== '') {
                        this.effectGroups.push(i);
                    }
                    lastBaseName = baseName;
                }
            },

            // ==================== ENCODING METHODS ====================

            encodeBrightness(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const adjustment = (brightness / 255) * (1 - params.factor);
                        data[i] = Math.max(0, data[i] - data[i] * adjustment);
                        data[i + 1] = Math.max(0, data[i + 1] - data[i + 1] * adjustment);
                        data[i + 2] = Math.max(0, data[i + 2] - data[i + 2] * adjustment);
                    }
                }
            },

            encodeContrast(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const factor = (brightness / 255) * params.factor * 0.1;
                        data[i] = Math.max(0, Math.min(255, 128 + (data[i] - 128) * (1 + factor)));
                        data[i + 1] = Math.max(0, Math.min(255, 128 + (data[i + 1] - 128) * (1 + factor)));
                        data[i + 2] = Math.max(0, Math.min(255, 128 + (data[i + 2] - 128) * (1 + factor)));
                    }
                }
            },

            encodeChannel(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const adjustment = (brightness / 255) * (1 - params.factor);
                        data[i + params.channel] = Math.max(0, data[i + params.channel] - data[i + params.channel] * adjustment);
                    }
                }
            },

            encodePureChannel(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const value = Math.floor(brightness * 0.3);
                        data[i + params.channel] = Math.max(0, Math.min(255, data[i + params.channel] + value));
                    }
                }
            },

            encodeInvert(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const strength = brightness / 255 * 0.3;
                        data[i] = Math.floor(data[i] * (1 - strength) + (255 - data[i]) * strength);
                        data[i + 1] = Math.floor(data[i + 1] * (1 - strength) + (255 - data[i + 1]) * strength);
                        data[i + 2] = Math.floor(data[i + 2] * (1 - strength) + (255 - data[i + 2]) * strength);
                    }
                }
            },

            encodeInvertChannel(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const strength = brightness / 255 * 0.3;
                        const ch = i + params.channel;
                        data[ch] = Math.floor(data[ch] * (1 - strength) + (255 - data[ch]) * strength);
                    }
                }
            },

            encodeBitPlane(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                const mask = 1 << params.bit;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const ch = i + params.channel;
                        
                        if (brightness > 128) {
                            data[ch] |= mask;
                        } else {
                            data[ch] &= ~mask;
                        }
                    }
                }
            },

            encodeColorDiff(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const adjustment = (brightness / 255) * params.strength * 20;
                        
                        data[i + params.ch1] = Math.max(0, Math.min(255, data[i + params.ch1] + adjustment));
                        data[i + params.ch2] = Math.max(0, Math.min(255, data[i + params.ch2] - adjustment));
                    }
                }
            },

            encodeGradient(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        if (content[i + 3] > 128) {
                            const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                            const adjustment = (brightness / 255) * 5;
                            
                            if (params.direction === 'horizontal' || params.direction === 'both') {
                                const leftI = (y * width + (x - 1)) * 4;
                                const rightI = (y * width + (x + 1)) * 4;
                                data[leftI] = Math.max(0, data[leftI] - adjustment);
                                data[rightI] = Math.max(0, data[rightI] + adjustment);
                            }
                            if (params.direction === 'vertical' || params.direction === 'both') {
                                const topI = ((y - 1) * width + x) * 4;
                                const bottomI = ((y + 1) * width + x) * 4;
                                data[topI + 1] = Math.max(0, data[topI + 1] - adjustment);
                                data[bottomI + 1] = Math.max(0, data[bottomI + 1] + adjustment);
                            }
                        }
                    }
                }
            },

            encodeAboveAverage(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                let sum = 0, count = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    count++;
                }
                const avg = sum / count;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        
                        if (pixelBrightness > avg) {
                            const adjustment = (brightness / 255) * params.strength * 30;
                            data[i] = Math.max(0, data[i] - adjustment);
                            data[i + 1] = Math.max(0, data[i + 1] - adjustment);
                            data[i + 2] = Math.max(0, data[i + 2] - adjustment);
                        }
                    }
                }
            },

            encodeBelowAverage(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                let sum = 0, count = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    count++;
                }
                const avg = sum / count;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        
                        if (pixelBrightness < avg) {
                            const adjustment = (brightness / 255) * params.strength * 30;
                            data[i] = Math.min(255, data[i] + adjustment);
                            data[i + 1] = Math.min(255, data[i + 1] + adjustment);
                            data[i + 2] = Math.min(255, data[i + 2] + adjustment);
                        }
                    }
                }
            },

            rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            },

            hslToRgb(h, s, l) {
                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            },

            encodeHue(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                        const newH = (h + (brightness / 255) * 0.05) % 1;
                        const [r, g, b] = this.hslToRgb(newH, s, l);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                    }
                }
            },

            encodeSaturation(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                        const newS = Math.max(0, Math.min(1, s - (brightness / 255) * 0.1));
                        const [r, g, b] = this.hslToRgb(h, newS, l);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                    }
                }
            },

            encodeLuminance(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                        const newL = Math.max(0, Math.min(1, l - (brightness / 255) * 0.1));
                        const [r, g, b] = this.hslToRgb(h, s, newL);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                    }
                }
            },

            encodeHueShift(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                        const newH = (h + (brightness / 255) * 0.1) % 1;
                        const [r, g, b] = this.hslToRgb(newH, s, l);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                    }
                }
            },

            encodeSatShift(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                        const newS = Math.max(0, Math.min(1, s + (brightness / 255) * 0.1));
                        const [r, g, b] = this.hslToRgb(h, newS, l);
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                    }
                }
            },

            encodeXOR(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const mask = Math.floor((brightness / 255) * params.value);
                        data[i] ^= mask;
                        data[i + 1] ^= mask;
                        data[i + 2] ^= mask;
                    }
                }
            },

            encodeEdge(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        if (content[i + 3] > 128) {
                            const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                            
                            const centerBright = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            const rightI = (y * width + (x + 1)) * 4;
                            const rightBright = (data[rightI] + data[rightI + 1] + data[rightI + 2]) / 3;
                            const edgeMag = Math.abs(centerBright - rightBright);
                            
                            if (edgeMag > params.threshold * 50) {
                                const adjustment = (brightness / 255) * 10;
                                data[i] = Math.max(0, Math.min(255, data[i] + adjustment));
                                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + adjustment));
                                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + adjustment));
                            }
                        }
                    }
                }
            },

            encodePosterize(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                const step = 256 / params.levels;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const offset = (brightness / 255) * (step / 2);
                        
                        data[i] = Math.floor((data[i] + offset) / step) * step;
                        data[i + 1] = Math.floor((data[i + 1] + offset) / step) * step;
                        data[i + 2] = Math.floor((data[i + 2] + offset) / step) * step;
                    }
                }
            },

            encodeModulo(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const offset = Math.floor((brightness / 255) * (params.value / 2));
                        
                        data[i] = (data[i] + offset) % params.value + Math.floor(data[i] / params.value) * params.value;
                        data[i + 1] = (data[i + 1] + offset) % params.value + Math.floor(data[i + 1] / params.value) * params.value;
                        data[i + 2] = (data[i + 2] + offset) % params.value + Math.floor(data[i + 2] / params.value) * params.value;
                    }
                }
            },

            encodeThreshold(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        
                        if (brightness > 128) {
                            if (pixelBrightness < params.value) {
                                const adjustment = (brightness / 255) * 5;
                                data[i] = Math.min(255, data[i] + adjustment);
                                data[i + 1] = Math.min(255, data[i + 1] + adjustment);
                                data[i + 2] = Math.min(255, data[i + 2] + adjustment);
                            }
                        } else {
                            if (pixelBrightness > params.value) {
                                const adjustment = (brightness / 255) * 5;
                                data[i] = Math.max(0, data[i] - adjustment);
                                data[i + 1] = Math.max(0, data[i + 1] - adjustment);
                                data[i + 2] = Math.max(0, data[i + 2] - adjustment);
                            }
                        }
                    }
                }
            },

            encodeGamma(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const strength = (brightness / 255) * 0.2;
                        const gamma = 1 + strength * (params.gamma - 1);
                        
                        data[i] = Math.pow(data[i] / 255, gamma) * 255;
                        data[i + 1] = Math.pow(data[i + 1] / 255, gamma) * 255;
                        data[i + 2] = Math.pow(data[i + 2] / 255, gamma) * 255;
                    }
                }
            },

            encodeColorTemp(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        const adjustment = (brightness / 255) * params.temp * 0.3;
                        
                        data[i] = Math.max(0, Math.min(255, data[i] + adjustment));
                        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] - adjustment));
                    }
                }
            },

            encodeSolarize(imageData, contentData, params) {
                const data = imageData.data;
                const content = contentData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (content[i + 3] > 128) {
                        const brightness = (content[i] + content[i + 1] + content[i + 2]) / 3;
                        
                        if (brightness > 128) {
                            const threshold = params.level;
                            if (data[i] > threshold) data[i] = 255 - data[i];
                            if (data[i + 1] > threshold) data[i + 1] = 255 - data[i + 1];
                            if (data[i + 2] > threshold) data[i + 2] = 255 - data[i + 2];
                        }
                    }
                }
            },

            // ==================== LIGHTING DETECTION METHODS (from Lucyra) ====================

            brightness(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * params.boost);
                    data[i + 1] = Math.min(255, data[i + 1] * params.boost);
                    data[i + 2] = Math.min(255, data[i + 2] * params.boost);
                }
            },

            contrast(data, params) {
                const factor = params.factor;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.max(0, Math.min(255, (data[i] - 128) * factor + 128));
                    data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * factor + 128));
                    data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * factor + 128));
                }
            },

            isolateChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const value = data[i + params.channel];
                    data[i] = params.channel === 0 ? value : 0;
                    data[i + 1] = params.channel === 1 ? value : 0;
                    data[i + 2] = params.channel === 2 ? value : 0;
                }
            },

            amplifyChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + params.channel] = Math.min(255, data[i + params.channel] * params.factor);
                }
            },

            invert(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
            },

            invertChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + params.channel] = 255 - data[i + params.channel];
                }
            },

            bitPlane(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const bit = (data[i + params.channel] >> params.bit) & 1;
                    const value = bit * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            colorDifference(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const diff = Math.min(255, Math.abs(data[i + params.ch1] - data[i + params.ch2]) * params.amp);
                    data[i] = diff;
                    data[i + 1] = diff;
                    data[i + 2] = diff;
                }
            },

            gradientDetect(data, params) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        let gx = 0, gy = 0;

                        if (params.direction === 'horizontal' || params.direction === 'both') {
                            const left = (y * width + x - 1) * 4;
                            const right = (y * width + x + 1) * 4;
                            gx = Math.abs(tempData[right] - tempData[left]);
                        }

                        if (params.direction === 'vertical' || params.direction === 'both') {
                            const top = ((y - 1) * width + x) * 4;
                            const bottom = ((y + 1) * width + x) * 4;
                            gy = Math.abs(tempData[bottom] - tempData[top]);
                        }

                        const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy) * 2);
                        data[i] = magnitude;
                        data[i + 1] = magnitude;
                        data[i + 2] = magnitude;
                    }
                }
            },

            aboveAverage(data, params) {
                let sum = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                const avg = sum / (data.length / 4);

                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const diff = brightness > avg ? (brightness - avg) * params.boost : 0;
                    data[i] = Math.min(255, diff);
                    data[i + 1] = Math.min(255, diff);
                    data[i + 2] = Math.min(255, diff);
                }
            },

            belowAverage(data, params) {
                let sum = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                const avg = sum / (data.length / 4);

                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const diff = brightness < avg ? (avg - brightness) * params.boost : 0;
                    data[i] = Math.min(255, diff);
                    data[i + 1] = Math.min(255, diff);
                    data[i + 2] = Math.min(255, diff);
                }
            },

            hueOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], 1, 0.5);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            saturationOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const value = hsl[1] * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            luminanceOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const value = hsl[2] * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            hueAmplified(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], Math.min(1, hsl[1] * 2), hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            saturationAmplified(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], Math.min(1, hsl[1] * 3), hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            xorPattern(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = data[i] ^ params.value;
                    data[i + 1] = data[i + 1] ^ params.value;
                    data[i + 2] = data[i + 2] ^ params.value;
                }
            },

            edgeDetect(data, params) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        
                        let gx = 0, gy = 0;
                        for (let c = 0; c < 3; c++) {
                            gx += -tempData[((y - 1) * width + x - 1) * 4 + c] +
                                   tempData[((y - 1) * width + x + 1) * 4 + c] +
                                  -2 * tempData[(y * width + x - 1) * 4 + c] +
                                   2 * tempData[(y * width + x + 1) * 4 + c] +
                                  -tempData[((y + 1) * width + x - 1) * 4 + c] +
                                   tempData[((y + 1) * width + x + 1) * 4 + c];
                            
                            gy += -tempData[((y - 1) * width + x - 1) * 4 + c] +
                                  -2 * tempData[((y - 1) * width + x) * 4 + c] +
                                  -tempData[((y - 1) * width + x + 1) * 4 + c] +
                                   tempData[((y + 1) * width + x - 1) * 4 + c] +
                                   2 * tempData[((y + 1) * width + x) * 4 + c] +
                                   tempData[((y + 1) * width + x + 1) * 4 + c];
                        }

                        const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy) * params.threshold / 3);
                        data[i] = magnitude;
                        data[i + 1] = magnitude;
                        data[i + 2] = magnitude;
                    }
                }
            },

            posterize(data, params) {
                const step = 256 / params.levels;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / step) * step;
                    data[i + 1] = Math.floor(data[i + 1] / step) * step;
                    data[i + 2] = Math.floor(data[i + 2] / step) * step;
                }
            },

            modulo(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = (data[i] % params.value) * (255 / params.value);
                    data[i + 1] = (data[i + 1] % params.value) * (255 / params.value);
                    data[i + 2] = (data[i + 2] % params.value) * (255 / params.value);
                }
            },

            threshold(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const value = brightness > params.value ? 255 : 0;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            gamma(data, params) {
                const gamma = params.gamma;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.pow(data[i] / 255, gamma) * 255;
                    data[i + 1] = Math.pow(data[i + 1] / 255, gamma) * 255;
                    data[i + 2] = Math.pow(data[i + 2] / 255, gamma) * 255;
                }
            },

            colorTemp(data, params) {
                const temp = params.temp;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.max(0, Math.min(255, data[i] + temp));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] - temp));
                }
            },

            solarize(data, params) {
                const level = params.level;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] > level) data[i] = 255 - data[i];
                    if (data[i + 1] > level) data[i + 1] = 255 - data[i + 1];
                    if (data[i + 2] > level) data[i + 2] = 255 - data[i + 2];
                }
            },

            // ==================== UI METHODS ====================

            setupEventListeners() {
                document.getElementById('base-image-input').addEventListener('change', (e) => this.loadBaseImage(e));
                
                const layerImageInput = document.getElementById('layer-image-input');
                layerImageInput.addEventListener('change', (e) => this.handleLayerImageLoad(e));

                const container = document.getElementById('canvas-container');
                container.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                container.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                container.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                container.addEventListener('mouseleave', (e) => this.handleCanvasMouseUp(e));
                container.addEventListener('wheel', (e) => this.handleCanvasWheel(e), { passive: false });

                // Lighting index input
                const lightingInput = document.getElementById('lighting-index-input');
                lightingInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const value = parseInt(lightingInput.value);
                        if (value >= 1 && value <= 177) {
                            this.currentLightingIndex = value - 1;
                            this.updateLightingDisplay();
                            this.render();
                        }
                        lightingInput.value = '';
                        lightingInput.blur();
                    }
                });

                window.addEventListener('resize', () => this.resizeCanvas());
            },

            loadBaseImage(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        this.baseImage = img;
                        this.scale = 1.0;
                        this.panX = 0;
                        this.panY = 0;
                        this.resizeCanvas();
                        this.render();
                        this.showHint('Base image loaded! Add text or images to hide.');
                        document.getElementById('download-btn').disabled = false;
                        document.getElementById('preview-toggle-btn').disabled = false;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            },

            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                if (this.baseImage) {
                    this.render();
                }
            },

            togglePreviewMode() {
                if (this.previewMode === 'encoding') {
                    this.previewMode = 'lighting';
                    document.getElementById('preview-toggle-btn').textContent = 'Switch to Encoding Preview';
                    document.getElementById('preview-toggle-btn').classList.add('preview-mode');
                    document.getElementById('encoding-mode-panel').style.display = 'none';
                    document.getElementById('lighting-mode-panel').style.display = 'block';
                    this.updateLightingDisplay();
                } else {
                    this.previewMode = 'encoding';
                    document.getElementById('preview-toggle-btn').textContent = 'Switch to Lighting Preview';
                    document.getElementById('preview-toggle-btn').classList.remove('preview-mode');
                    document.getElementById('encoding-mode-panel').style.display = 'block';
                    document.getElementById('lighting-mode-panel').style.display = 'none';
                }
                this.render();
            },

            updateLightingDisplay() {
                const effect = this.lightingEffects[this.currentLightingIndex];
                document.getElementById('lighting-name').textContent = effect.name;
                document.getElementById('lighting-index').textContent = `${this.currentLightingIndex + 1} / ${this.lightingEffects.length}`;
            },

            resetView() {
                this.scale = 1.0;
                this.panX = 0;
                this.panY = 0;
                document.getElementById('zoom-value-lighting').textContent = '100%';
                this.render();
                this.showHint('View reset!', 1500);
            },

            addTextLayer() {
                if (!this.baseImage) {
                    this.showHint('Please load a base image first!');
                    return;
                }

                // Create layer in image coordinate space (center of image)
                const layer = {
                    id: this.nextLayerId++,
                    type: 'text',
                    content: 'Hidden Text',
                    x: this.baseImage.width / 2 - 100,
                    y: this.baseImage.height / 2 - 25,
                    width: 200,
                    height: 50,
                    rotation: 0,
                    effectIndex: 0,
                    inverted: false
                };

                this.layers.push(layer);
                this.selectedLayerId = layer.id;
                this.cachedEncodedImage = null;
                this.updateLayersUI();
                
                // Force multiple renders to ensure container box appears
                this.render();
                setTimeout(() => {
                    this.render();
                }, 0);
                setTimeout(() => {
                    this.render();
                }, 50);
                
                this.showHint('Text layer added! Scroll over it to change effect.', 2000);
            },

            addImageLayer() {
                if (!this.baseImage) {
                    this.showHint('Please load a base image first!');
                    return;
                }

                this.pendingImageLayerId = this.nextLayerId++;
                document.getElementById('layer-image-input').click();
            },

            handleLayerImageLoad(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Scale image to fit within base image if too large (in image space)
                        let width = img.width;
                        let height = img.height;
                        const maxDim = Math.min(this.baseImage.width * 0.5, this.baseImage.height * 0.5);
                        
                        if (width > maxDim || height > maxDim) {
                            const scale = maxDim / Math.max(width, height);
                            width *= scale;
                            height *= scale;
                        }

                        // Convert to grayscale and dither at final size
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = Math.floor(width);
                        tempCanvas.height = Math.floor(height);
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        this.convertToBlackAndWhite(imageData);
                        tempCtx.putImageData(imageData, 0, 0);

                        // Position in image coordinate space
                        const layer = {
                            id: this.pendingImageLayerId,
                            type: 'image',
                            content: tempCanvas.toDataURL(),
                            image: tempCanvas,
                            x: this.baseImage.width / 2 - width / 2,
                            y: this.baseImage.height / 2 - height / 2,
                            width: width,
                            height: height,
                            rotation: 0,
                            effectIndex: 0,
                            originalImage: img,
                            inverted: false
                        };

                        this.layers.push(layer);
                        this.selectedLayerId = layer.id;
                        this.cachedEncodedImage = null;
                        this.updateLayersUI();
                        
                        // Force multiple renders to ensure container box appears
                        this.render();
                        setTimeout(() => {
                            this.render();
                        }, 0);
                        setTimeout(() => {
                            this.render();
                        }, 50);
                        
                        this.showHint('Image layer added! Scroll over it to change effect.', 2000);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            },

            convertToBlackAndWhite(imageData, invert = false) {
                const data = imageData.data;
                
                // Convert to grayscale
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
                
                // Floyd-Steinberg dithering
                for (let y = 0; y < imageData.height; y++) {
                    for (let x = 0; x < imageData.width; x++) {
                        const i = (y * imageData.width + x) * 4;
                        const oldPixel = data[i];
                        let newPixel = oldPixel > 128 ? 255 : 0;
                        
                        // Invert if requested
                        if (invert) {
                            newPixel = 255 - newPixel;
                        }
                        
                        data[i] = newPixel;
                        data[i + 1] = newPixel;
                        data[i + 2] = newPixel;
                        
                        const error = oldPixel - (invert ? 255 - newPixel : newPixel);
                        
                        if (x + 1 < imageData.width) {
                            const ri = i + 4;
                            data[ri] += error * 7/16;
                            data[ri + 1] += error * 7/16;
                            data[ri + 2] += error * 7/16;
                        }
                        if (y + 1 < imageData.height) {
                            if (x > 0) {
                                const bli = i + imageData.width * 4 - 4;
                                data[bli] += error * 3/16;
                                data[bli + 1] += error * 3/16;
                                data[bli + 2] += error * 3/16;
                            }
                            const bi = i + imageData.width * 4;
                            data[bi] += error * 5/16;
                            data[bi + 1] += error * 5/16;
                            data[bi + 2] += error * 5/16;
                            
                            if (x + 1 < imageData.width) {
                                const bri = i + imageData.width * 4 + 4;
                                data[bri] += error * 1/16;
                                data[bri + 1] += error * 1/16;
                                data[bri + 2] += error * 1/16;
                            }
                        }
                    }
                }
            },

            updateLayersUI() {
                const container = document.getElementById('layers-container');
                container.innerHTML = '';

                this.layers.forEach((layer, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'layer-item' + (layer.id === this.selectedLayerId ? ' selected' : '');

                    // Header with radio, content, delete
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'layer-header';
                    headerDiv.onclick = (e) => {
                        if (!e.target.classList.contains('delete-btn') && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                            this.selectLayer(layer.id);
                        }
                    };

                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = 'layer';
                    radio.checked = layer.id === this.selectedLayerId;
                    radio.onchange = () => this.selectLayer(layer.id);

                    if (layer.type === 'text') {
                        const textarea = document.createElement('textarea');
                        textarea.value = layer.content;
                        textarea.onclick = (e) => e.stopPropagation();
                        textarea.oninput = (e) => {
                            layer.content = e.target.value;
                            this.cachedEncodedImage = null;
                            this.render();
                        };
                        headerDiv.appendChild(radio);
                        headerDiv.appendChild(textarea);
                    } else {
                        const label = document.createElement('span');
                        label.textContent = `Image ${index + 1}`;
                        label.style.flex = '1';
                        headerDiv.appendChild(radio);
                        headerDiv.appendChild(label);
                    }

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteLayer(layer.id);
                    };
                    headerDiv.appendChild(deleteBtn);

                    // Controls
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'layer-controls';
                    
                    const effectLabel = document.createElement('label');
                    effectLabel.textContent = 'Effect #:';
                    
                    const effectInput = document.createElement('input');
                    effectInput.type = 'number';
                    effectInput.min = '1';
                    effectInput.max = '177';
                    effectInput.value = layer.effectIndex + 1;
                    effectInput.onclick = (e) => e.stopPropagation();
                    effectInput.onchange = (e) => {
                        const val = parseInt(e.target.value);
                        if (val >= 1 && val <= 177) {
                            layer.effectIndex = val - 1;
                            this.cachedEncodedImage = null;
                            this.updateLayersUI();
                            this.render();
                        }
                    };
                    
                    controlsDiv.appendChild(effectLabel);
                    controlsDiv.appendChild(effectInput);
                    
                    // Invert button
                    const invertBtn = document.createElement('button');
                    invertBtn.textContent = layer.inverted ? 'Inverted' : 'Normal';
                    invertBtn.style.width = 'auto';
                    invertBtn.style.padding = '4px 8px';
                    invertBtn.style.fontSize = '10px';
                    invertBtn.style.marginLeft = '5px';
                    invertBtn.onclick = (e) => {
                        e.stopPropagation();
                        layer.inverted = !layer.inverted;
                        this.cachedEncodedImage = null;
                        
                        // If it's an image layer, regenerate the dithered image with inverted colors
                        if (layer.type === 'image' && layer.originalImage) {
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = Math.floor(layer.width);
                            tempCanvas.height = Math.floor(layer.height);
                            tempCtx.drawImage(layer.originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
                            
                            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                            this.convertToBlackAndWhite(imageData, layer.inverted);
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            layer.image = tempCanvas;
                            layer.content = tempCanvas.toDataURL();
                        }
                        
                        this.updateLayersUI();
                        this.render();
                    };
                    controlsDiv.appendChild(invertBtn);

                    const effectName = document.createElement('div');
                    effectName.className = 'effect-name';
                    effectName.textContent = this.stegoEffects[layer.effectIndex].name;
                    
                    itemDiv.appendChild(headerDiv);
                    itemDiv.appendChild(controlsDiv);
                    itemDiv.appendChild(effectName);
                    container.appendChild(itemDiv);
                });
            },

            selectLayer(id) {
                this.selectedLayerId = id;
                this.updateLayersUI();
                this.render();
            },

            deleteLayer(id) {
                this.layers = this.layers.filter(l => l.id !== id);
                if (this.selectedLayerId === id) {
                    this.selectedLayerId = this.layers.length > 0 ? this.layers[0].id : null;
                }
                this.cachedEncodedImage = null;
                this.updateLayersUI();
                this.render();
            },

            handleCanvasMouseDown(e) {
                if (e.button !== 0) return; // Only left click

                const rect = this.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Convert to view space (accounting for pan and zoom)
                const viewX = (canvasX - this.panX) / this.scale;
                const viewY = (canvasY - this.panY) / this.scale;
                
                // Convert to image space
                const imgCoords = this.canvasToImage(viewX, viewY);
                const x = imgCoords.x;
                const y = imgCoords.y;

                // In lighting mode or with Ctrl, always pan
                if (this.previewMode === 'lighting' || e.ctrlKey) {
                    this.isPanning = true;
                    this.panStartX = e.clientX;
                    this.panStartY = e.clientY;
                    this.lastPanX = this.panX;
                    this.lastPanY = this.panY;
                    document.getElementById('canvas-container').classList.add('dragging');
                    return;
                }

                // In encoding mode, check if clicking on selected layer
                if (this.selectedLayerId !== null) {
                    const layer = this.layers.find(l => l.id === this.selectedLayerId);
                    if (layer) {
                        const cx = layer.x + layer.width / 2;
                        const cy = layer.y + layer.height / 2;
                        
                        // Check rotation handle first (in image space)
                        const rotHandleX = cx;
                        const rotHandleY = layer.y - 20;
                        const rotCos = Math.cos(layer.rotation);
                        const rotSin = Math.sin(layer.rotation);
                        const rhx = rotHandleX - cx;
                        const rhy = rotHandleY - cy;
                        const rotatedRHX = rhx * rotCos - rhy * rotSin + cx;
                        const rotatedRHY = rhx * rotSin + rhy * rotCos + cy;
                        
                        if (Math.abs(x - rotatedRHX) < 15 && Math.abs(y - rotatedRHY) < 15) {
                            this.isRotating = true;
                            this.rotationCenter = { x: cx, y: cy };
                            this.initialRotation = layer.rotation;
                            this.initialAngle = Math.atan2(y - cy, x - cx);
                            return;
                        }

                        // Transform point to layer's local coordinate system
                        const cos = Math.cos(-layer.rotation);
                        const sin = Math.sin(-layer.rotation);
                        const dx = x - cx;
                        const dy = y - cy;
                        const localX = dx * cos - dy * sin + cx;
                        const localY = dx * sin + dy * cos + cy;

                        // Check resize handle
                        const handleSize = 15;
                        if (localX >= layer.x + layer.width - handleSize && 
                            localX <= layer.x + layer.width &&
                            localY >= layer.y + layer.height - handleSize && 
                            localY <= layer.y + layer.height) {
                            this.isResizing = true;
                            this.resizeStartX = localX;
                            this.resizeStartY = localY;
                            this.resizeStartWidth = layer.width;
                            this.resizeStartHeight = layer.height;
                            this.maintainAspect = e.shiftKey;
                            this.originalAspect = layer.width / layer.height;
                            return;
                        }

                        // Check if inside box
                        if (localX >= layer.x && localX <= layer.x + layer.width &&
                            localY >= layer.y && localY <= layer.y + layer.height) {
                            this.isDragging = true;
                            this.dragOffsetX = x - layer.x;
                            this.dragOffsetY = y - layer.y;
                            return;
                        }
                    }
                }

                // If not clicking on layer, pan
                this.isPanning = true;
                this.panStartX = e.clientX;
                this.panStartY = e.clientY;
                this.lastPanX = this.panX;
                this.lastPanY = this.panY;
                document.getElementById('canvas-container').classList.add('dragging');
            },

            handleCanvasMouseMove(e) {
                if (this.isPanning) {
                    const dx = e.clientX - this.panStartX;
                    const dy = e.clientY - this.panStartY;
                    this.panX = this.lastPanX + dx;
                    this.panY = this.lastPanY + dy;
                    this.render();
                    return;
                }

                if (this.selectedLayerId === null) return;
                if (!this.isDragging && !this.isResizing && !this.isRotating) return;

                const rect = this.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Convert to view space
                const viewX = (canvasX - this.panX) / this.scale;
                const viewY = (canvasY - this.panY) / this.scale;
                
                // Convert to image space
                const imgCoords = this.canvasToImage(viewX, viewY);
                const x = imgCoords.x;
                const y = imgCoords.y;

                const layer = this.layers.find(l => l.id === this.selectedLayerId);
                if (!layer) return;

                if (this.isDragging) {
                    layer.x = x - this.dragOffsetX;
                    layer.y = y - this.dragOffsetY;
                    this.cachedEncodedImage = null;
                    this.render();
                } else if (this.isResizing) {
                    // Transform mouse to layer space
                    const cx = layer.x + layer.width / 2;
                    const cy = layer.y + layer.height / 2;
                    const cos = Math.cos(-layer.rotation);
                    const sin = Math.sin(-layer.rotation);
                    const dx = x - cx;
                    const dy = y - cy;
                    const localX = dx * cos - dy * sin + cx;
                    const localY = dx * sin + dy * cos + cy;
                    
                    const deltaX = localX - this.resizeStartX;
                    const deltaY = localY - this.resizeStartY;
                    
                    let newWidth = Math.max(20, this.resizeStartWidth + deltaX);
                    let newHeight = Math.max(15, this.resizeStartHeight + deltaY);
                    
                    // Maintain aspect ratio if shift is held
                    if (this.maintainAspect || e.shiftKey) {
                        const aspectRatio = this.originalAspect;
                        // Use the larger dimension change
                        if (Math.abs(deltaX) > Math.abs(deltaY / aspectRatio)) {
                            newHeight = newWidth / aspectRatio;
                        } else {
                            newWidth = newHeight * aspectRatio;
                        }
                        newWidth = Math.max(20, newWidth);
                        newHeight = Math.max(15, newHeight);
                    }
                    
                    // If image layer, re-dither at new size
                    if (layer.type === 'image' && layer.originalImage) {
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = Math.floor(newWidth);
                        tempCanvas.height = Math.floor(newHeight);
                        tempCtx.drawImage(layer.originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        this.convertToBlackAndWhite(imageData, layer.inverted);
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        layer.image = tempCanvas;
                        layer.content = tempCanvas.toDataURL();
                    }
                    
                    layer.width = newWidth;
                    layer.height = newHeight;
                    this.cachedEncodedImage = null;
                    this.render();
                } else if (this.isRotating) {
                    const cx = this.rotationCenter.x;
                    const cy = this.rotationCenter.y;
                    const currentAngle = Math.atan2(y - cy, x - cx);
                    layer.rotation = this.initialRotation + (currentAngle - this.initialAngle);
                    this.cachedEncodedImage = null;
                    this.render();
                }
            },

            handleCanvasMouseUp(e) {
                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                this.isPanning = false;
                document.getElementById('canvas-container').classList.remove('dragging');
            },

            handleCanvasWheel(e) {
                e.preventDefault();

                if (e.ctrlKey) {
                    // Zoom
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const oldScale = this.scale;
                    this.scale = Math.max(0.1, Math.min(10, this.scale * zoomFactor));
                    
                    // Zoom towards mouse
                    this.panX = mouseX - (mouseX - this.panX) * (this.scale / oldScale);
                    this.panY = mouseY - (mouseY - this.panY) * (this.scale / oldScale);
                    
                    const zoomText = Math.round(this.scale * 100) + '%';
                    document.getElementById('zoom-value-lighting').textContent = zoomText;
                    this.render();
                    return;
                }

                if (this.previewMode === 'lighting') {
                    // Change lighting effect
                    if (e.altKey) {
                        // Jump through effect groups with wrapping
                        if (e.deltaY < 0) {
                            // Next group
                            let found = false;
                            for (let i = 0; i < this.effectGroups.length; i++) {
                                if (this.effectGroups[i] > this.currentLightingIndex) {
                                    this.currentLightingIndex = this.effectGroups[i];
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                // Wrap to first
                                this.currentLightingIndex = 0;
                            }
                        } else {
                            // Previous group
                            let found = false;
                            for (let i = this.effectGroups.length - 1; i >= 0; i--) {
                                if (this.effectGroups[i] < this.currentLightingIndex) {
                                    this.currentLightingIndex = this.effectGroups[i];
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                // Wrap to last
                                this.currentLightingIndex = this.lightingEffects.length - 1;
                            }
                        }
                    } else {
                        // Regular scroll with wrapping
                        if (e.deltaY < 0) {
                            this.currentLightingIndex = (this.currentLightingIndex + 1) % this.lightingEffects.length;
                        } else {
                            this.currentLightingIndex = (this.currentLightingIndex - 1 + this.lightingEffects.length) % this.lightingEffects.length;
                        }
                    }
                    this.updateLightingDisplay();
                    this.render();
                    return;
                }

                // Encoding mode - change layer effect
                if (this.selectedLayerId === null) return;

                const layer = this.layers.find(l => l.id === this.selectedLayerId);
                if (!layer) return;

                const rect = this.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                
                // Convert to view space
                const viewX = (canvasX - this.panX) / this.scale;
                const viewY = (canvasY - this.panY) / this.scale;
                
                // Convert to image space
                const imgCoords = this.canvasToImage(viewX, viewY);
                const x = imgCoords.x;
                const y = imgCoords.y;

                // Transform to layer space
                const cx = layer.x + layer.width / 2;
                const cy = layer.y + layer.height / 2;
                const cos = Math.cos(-layer.rotation);
                const sin = Math.sin(-layer.rotation);
                const dx = x - cx;
                const dy = y - cy;
                const localX = dx * cos - dy * sin + cx;
                const localY = dx * sin + dy * cos + cy;

                if (localX >= layer.x && localX <= layer.x + layer.width &&
                    localY >= layer.y && localY <= layer.y + layer.height) {
                    
                    if (e.deltaY < 0) {
                        layer.effectIndex = (layer.effectIndex + 1) % this.stegoEffects.length;
                    } else {
                        layer.effectIndex = (layer.effectIndex - 1 + this.stegoEffects.length) % this.stegoEffects.length;
                    }

                    this.cachedEncodedImage = null; // Invalidate cache immediately
                    this.updateLayersUI();
                    this.render(); // Render immediately
                    this.showHint(this.stegoEffects[layer.effectIndex].name);
                }
            },

            generateEncodedImage() {
                if (!this.baseImage) return null;

                // Create output canvas at base image size
                const outputCanvas = document.createElement('canvas');
                const outputCtx = outputCanvas.getContext('2d');
                outputCanvas.width = this.baseImage.width;
                outputCanvas.height = this.baseImage.height;

                // Draw base image
                outputCtx.drawImage(this.baseImage, 0, 0);
                const outputData = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);

                // Apply each layer (layer coordinates are already in image space)
                this.layers.forEach(layer => {
                    const contentCanvas = document.createElement('canvas');
                    const contentCtx = contentCanvas.getContext('2d');
                    contentCanvas.width = outputCanvas.width;
                    contentCanvas.height = outputCanvas.height;
                    
                    contentCtx.save();
                    const cx = layer.x + layer.width / 2;
                    const cy = layer.y + layer.height / 2;
                    contentCtx.translate(cx, cy);
                    contentCtx.rotate(layer.rotation);
                    contentCtx.translate(-cx, -cy);

                    // Use white for normal, black for inverted
                    contentCtx.fillStyle = layer.inverted ? 'black' : 'white';
                    // Reduced minimum font size to 6px to allow better vertical compression
                    contentCtx.font = `bold ${Math.max(6, Math.floor(layer.height / 3))}px Arial`;
                    contentCtx.textAlign = 'center';
                    contentCtx.textBaseline = 'middle';

                    if (layer.type === 'text') {
                        const lines = layer.content.split('\n');
                        const lineHeight = layer.height / (lines.length + 1);
                        const startY = layer.y + lineHeight;
                        lines.forEach((line, i) => {
                            contentCtx.fillText(line, layer.x + layer.width / 2, startY + i * lineHeight, layer.width - 20);
                        });
                    } else if (layer.type === 'image' && layer.image) {
                        contentCtx.drawImage(layer.image, layer.x, layer.y, layer.width, layer.height);
                    }
                    
                    contentCtx.restore();

                    const contentData = contentCtx.getImageData(0, 0, contentCanvas.width, contentCanvas.height);

                    // Apply steganography effect
                    const effect = this.stegoEffects[layer.effectIndex];
                    effect.encode.call(this, outputData, contentData, effect.params);
                });

                // Put encoded data back
                outputCtx.putImageData(outputData, 0, 0);
                return outputCanvas;
            },

            render() {
                if (!this.baseImage) return;

                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Apply zoom and pan
                this.ctx.translate(this.panX, this.panY);
                this.ctx.scale(this.scale, this.scale);

                if (this.previewMode === 'lighting') {
                    // Show encoded image with lighting effect applied
                    if (!this.cachedEncodedImage && this.layers.length > 0) {
                        this.cachedEncodedImage = this.generateEncodedImage();
                    }
                    
                    if (this.cachedEncodedImage) {
                        // Draw to temp canvas to apply lighting
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = this.canvas.width;
                        tempCanvas.height = this.canvas.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        const imgAspect = this.cachedEncodedImage.width / this.cachedEncodedImage.height;
                        const canvasAspect = this.canvas.width / this.canvas.height;
                        let drawW, drawH, drawX, drawY;
                        
                        if (imgAspect > canvasAspect) {
                            drawW = this.canvas.width;
                            drawH = drawW / imgAspect;
                            drawX = 0;
                            drawY = (this.canvas.height - drawH) / 2;
                        } else {
                            drawH = this.canvas.height;
                            drawW = drawH * imgAspect;
                            drawY = 0;
                            drawX = (this.canvas.width - drawW) / 2;
                        }
                        
                        tempCtx.drawImage(this.cachedEncodedImage, drawX, drawY, drawW, drawH);
                        
                        const imageData = tempCtx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                        const effect = this.lightingEffects[this.currentLightingIndex];
                        effect.apply.call(this, imageData.data, effect.params);
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        this.ctx.drawImage(tempCanvas, 0, 0);
                    } else {
                        // No layers yet, just show base image
                        const imgAspect = this.baseImage.width / this.baseImage.height;
                        const canvasAspect = this.canvas.width / this.canvas.height;
                        let drawW, drawH, drawX, drawY;
                        
                        if (imgAspect > canvasAspect) {
                            drawW = this.canvas.width;
                            drawH = drawW / imgAspect;
                            drawX = 0;
                            drawY = (this.canvas.height - drawH) / 2;
                        } else {
                            drawH = this.canvas.height;
                            drawW = drawH * imgAspect;
                            drawY = 0;
                            drawX = (this.canvas.width - drawW) / 2;
                        }
                        
                        this.ctx.drawImage(this.baseImage, drawX, drawY, drawW, drawH);
                    }
                } else {
                    // Encoding mode - show preview with effects applied
                    if (!this.cachedEncodedImage && this.layers.length > 0) {
                        this.cachedEncodedImage = this.generateEncodedImage();
                    }
                    
                    if (this.cachedEncodedImage) {
                        const imgAspect = this.cachedEncodedImage.width / this.cachedEncodedImage.height;
                        const canvasAspect = this.canvas.width / this.canvas.height;
                        let drawW, drawH, drawX, drawY;
                        
                        if (imgAspect > canvasAspect) {
                            drawW = this.canvas.width;
                            drawH = drawW / imgAspect;
                            drawX = 0;
                            drawY = (this.canvas.height - drawH) / 2;
                        } else {
                            drawH = this.canvas.height;
                            drawW = drawH * imgAspect;
                            drawY = 0;
                            drawX = (this.canvas.width - drawW) / 2;
                        }
                        
                        this.ctx.drawImage(this.cachedEncodedImage, drawX, drawY, drawW, drawH);
                    } else {
                        // No layers yet, just show base image
                        const imgAspect = this.baseImage.width / this.baseImage.height;
                        const canvasAspect = this.canvas.width / this.canvas.height;
                        let drawW, drawH, drawX, drawY;
                        
                        if (imgAspect > canvasAspect) {
                            drawW = this.canvas.width;
                            drawH = drawW / imgAspect;
                            drawX = 0;
                            drawY = (this.canvas.height - drawH) / 2;
                        } else {
                            drawH = this.canvas.height;
                            drawW = drawH * imgAspect;
                            drawY = 0;
                            drawX = (this.canvas.width - drawW) / 2;
                        }
                        
                        this.ctx.drawImage(this.baseImage, drawX, drawY, drawW, drawH);
                    }

                    // Draw container boxes for selected layer
                    if (this.selectedLayerId !== null) {
                        const layer = this.layers.find(l => l.id === this.selectedLayerId);
                        if (layer) {
                            // Get transform from image coords to canvas coords
                            const transform = this.getImageToCanvasTransform();
                            
                            this.ctx.save();
                            
                            // Transform layer coordinates to canvas display coordinates
                            const displayX = layer.x * transform.scale + transform.offsetX;
                            const displayY = layer.y * transform.scale + transform.offsetY;
                            const displayWidth = layer.width * transform.scale;
                            const displayHeight = layer.height * transform.scale;
                            
                            const cx = displayX + displayWidth / 2;
                            const cy = displayY + displayHeight / 2;
                            this.ctx.translate(cx, cy);
                            this.ctx.rotate(layer.rotation);
                            this.ctx.translate(-cx, -cy);
                            
                            // Border
                            this.ctx.strokeStyle = '#ff00d4';
                            this.ctx.lineWidth = 2 / this.scale;
                            this.ctx.setLineDash([5 / this.scale, 5 / this.scale]);
                            this.ctx.strokeRect(displayX, displayY, displayWidth, displayHeight);
                            this.ctx.setLineDash([]);

                            // Resize handle
                            this.ctx.fillStyle = '#ff00d4';
                            this.ctx.fillRect(displayX + displayWidth - 15, displayY + displayHeight - 15, 15, 15);
                            
                            // Rotation handle
                            this.ctx.beginPath();
                            this.ctx.arc(displayX + displayWidth / 2, displayY - 20, 8, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.strokeStyle = '#fff';
                            this.ctx.lineWidth = 2 / this.scale;
                            this.ctx.stroke();
                            
                            this.ctx.restore();
                        }
                    }
                }

                this.ctx.restore();
            },

            downloadImage() {
                if (!this.baseImage || this.layers.length === 0) {
                    this.showHint('Add at least one hidden layer first!');
                    return;
                }

                this.showHint('Encoding hidden data...', 2000);

                setTimeout(() => {
                    const outputCanvas = this.generateEncodedImage();
                    if (!outputCanvas) return;

                    outputCanvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'inknigma_encoded.png';
                        a.click();
                        URL.revokeObjectURL(url);
                        this.showHint('Image downloaded! Test with Lucyra.', 3000);
                    });
                }, 100);
            },

            showHint(text, duration = 2000) {
                const hint = document.getElementById('hint');
                hint.textContent = text;
                hint.classList.add('visible');

                if (duration > 0) {
                    setTimeout(() => {
                        hint.classList.remove('visible');
                    }, duration);
                }
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>